"""Unit tests for {{game_name}} environment."""

import pytest
import numpy as np

from rl_arena.envs.{{game_name_lower}} import {{class_name}}Environment


class Test{{class_name}}Environment:
    """Test suite for {{class_name}}Environment."""

    def test_initialization(self):
        """Test environment initialization."""
        env = {{class_name}}Environment()
        assert env is not None
        assert env.num_players == 2  # TODO: Adjust if different
        assert env.action_space is not None
        assert env.observation_space is not None

    def test_reset(self):
        """Test reset functionality."""
        env = {{class_name}}Environment()
        observations, info = env.reset(seed=42)

        # Check observations
        assert isinstance(observations, list)
        assert len(observations) == env.num_players
        for obs in observations:
            assert env.observation_space.contains(obs)

        # Check info
        assert isinstance(info, dict)
        assert "step" in info
        assert info["step"] == 0

    def test_reset_determinism(self):
        """Test that reset with same seed produces same initial state."""
        env = {{class_name}}Environment()

        obs1, _ = env.reset(seed=42)
        obs2, _ = env.reset(seed=42)

        # Observations should be identical
        for o1, o2 in zip(obs1, obs2):
            if isinstance(o1, np.ndarray):
                np.testing.assert_array_equal(o1, o2)
            else:
                assert o1 == o2

    def test_step(self):
        """Test step functionality."""
        env = {{class_name}}Environment()
        env.reset(seed=42)

        # Sample actions
        actions = [env.action_space.sample() for _ in range(env.num_players)]

        # Take step
        observations, rewards, terminated, truncated, info = env.step(actions)

        # Check observations
        assert isinstance(observations, list)
        assert len(observations) == env.num_players
        for obs in observations:
            assert env.observation_space.contains(obs)

        # Check rewards
        assert isinstance(rewards, list)
        assert len(rewards) == env.num_players
        for reward in rewards:
            assert isinstance(reward, (int, float, np.number))

        # Check flags
        assert isinstance(terminated, bool)
        assert isinstance(truncated, bool)

        # Check info
        assert isinstance(info, dict)

    def test_invalid_action_count(self):
        """Test that wrong number of actions raises error."""
        env = {{class_name}}Environment()
        env.reset(seed=42)

        # Try with wrong number of actions
        with pytest.raises(ValueError):
            env.step([env.action_space.sample()])  # Only 1 action instead of 2

    def test_invalid_action_value(self):
        """Test that invalid action values raise error."""
        env = {{class_name}}Environment()
        env.reset(seed=42)

        # TODO: Implement test based on your action space
        # Example for Discrete space:
        # with pytest.raises(ValueError):
        #     env.step([999, 999])  # Out of range

    def test_episode_termination(self):
        """Test that episodes terminate eventually."""
        env = {{class_name}}Environment({"max_steps": 100})
        env.reset(seed=42)

        terminated = False
        truncated = False
        steps = 0

        while not (terminated or truncated) and steps < 200:
            actions = [env.action_space.sample() for _ in range(env.num_players)]
            _, _, terminated, truncated, _ = env.step(actions)
            steps += 1

        # Should terminate within max_steps
        assert terminated or truncated
        assert steps <= 100

    def test_render_modes(self):
        """Test that all render modes work."""
        env = {{class_name}}Environment()
        env.reset(seed=42)

        # Test each render mode
        render_modes = ["rgb_array", "ansi"]

        for mode in render_modes:
            result = env.render(mode=mode)

            if mode == "rgb_array":
                assert isinstance(result, np.ndarray)
                assert result.ndim == 3
                assert result.shape[2] == 3  # RGB channels
            elif mode == "ansi":
                assert isinstance(result, str)
                assert len(result) > 0

    def test_state_recording(self):
        """Test state recording for replay."""
        env = {{class_name}}Environment()
        env.enable_state_recording(True)
        env.reset(seed=42)

        # Take a few steps
        for _ in range(5):
            actions = [env.action_space.sample() for _ in range(env.num_players)]
            env.step(actions)

        # Get states
        states = env.get_state_history()
        assert len(states) == 6  # Initial + 5 steps

    def test_configuration(self):
        """Test custom configuration."""
        config = {
            "max_steps": 50,
            # TODO: Add your custom config options
        }

        env = {{class_name}}Environment(configuration=config)
        assert env.max_steps == 50

    # TODO: Add game-specific tests
    # Examples:
    # - test_scoring_mechanism()
    # - test_collision_detection()
    # - test_physics_simulation()
    # - test_win_conditions()
    # - test_edge_cases()


def test_environment_validation():
    """Test that environment passes validation."""
    from rl_arena.tools import validate_environment

    # This should not raise an error
    result = validate_environment({{class_name}}Environment, verbose=False)
    assert result is True
